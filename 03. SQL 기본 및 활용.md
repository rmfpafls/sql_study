# 01. SQL 기본 
## 02. SQL 종류 
### 04. select문 
1. select 
```sql 
select * 
from EMP 
where 사원번호 = 1000;
```
- select 칼럼 지정 
```sql 
select Ename || '님' from EMP;
-- EMP 테이블의모든행에 Ename 칼럼을 조회한다.
-- 단, Ename 칼럼 뒤에 '님'이라는 문자를 결합한다. 
```
- 오름차순 정렬 
```sql 
select * from EMP
	order by Ename;
```
- 내림차순 정렬
```sql 
select * from EMP 
	order by sal DESC;
-- DESC를 붙이면 내림차순 정렬
```

### 2. Distinct와 Alias
1. Distinct 
: 데이터를 한 번만 조회한다. 
```sql 
select distinct deptno from EMP order by deptno;
-- distinct가 deptno의 중복된 데이터를 제거해준다.
```

2. Alias
: 테이블명이나 칼럼명이 너무 길어서 간략하게 할 때 사용한다.
```sql
select Ename as "이름" from EMP a;
칼럼명을 '이름'으로 출력하고, EMP 테이블 명 대신에 a를 사용한다.
```

### 3. where문 사용

1. where 문이 사용하는 연산자

| 연산자                 | 설명                                |
| ------------------- | --------------------------------- |
| <>                  | 같지 않은 것을 조회한다.                    |
| NOT 칼럼명 =           | 같지 않은 것을 조회한다.                    |
| like '%비교 문자열%'     | 비교 문자열을 조회한다. '%'는 모든 값을 의미한다.    |
| between a and b     | a와 b 사이의 값을 조회한다.                 |
| in (list)           | or를 의미하며 list 값 중에 하나만 일치해도 조회된다. |
| is null             | null 값을 조회한다.                     |
| not between a and b | a와 b 사이의 해당되지 않는 값을 조회한다.         |
| not in (list)       | list오 불일치한 것을 조회한다.               |
| is not null         | null 값이 아닌 것을 조회한다.               |

2. like 문 사용

| 와일드 카드         | 설명                                                                                                                            |
| -------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| %              | - 어떤 문자를 포함한 모든 것을 조회한다.<br>- ex) 조% => 조로 시작하는 모든 단어<br>- %est% : 중간에 est가 있는 모든 것을 조회한다.<br>- like문에 와일드카드를 사용하지 않으면 =와 같다. |
| __(underscore) | 한 개인 단일 문자를 의미한다.                                                                                                             |

5.  null 값 조회
: null과 어떤 값을 비교할 때, '알 수 없음'이 반환된다.
: null 값 조회
	: null을 조회할 경우는 is null을 사용하고, null 값이 아닌 것을 조회할 경우는 is not null을 사용한다

| null 함수  | 설명                                                                                                                     |
| -------- | ---------------------------------------------------------------------------------------------------------------------- |
| NVL함수    | null 값이면 다른 값으로 바꾸는 함수<br>- 'NVL(MGR,0)'이면 MGR 칼럼이 null이면 0으로 바뀐다.                                                     |
| NVL2함수   | 'NVL(MGR,0,1)'이면 MGR 칼럼이 null이면 0으로 아니면 1로 바뀐다.                                                                        |
| NULLIF함수 | - 두 개의 값이 같으면 Null을, 같지 않으면 첫 번째 값을 반환한다.<br>- 'NULLIF(expr1,expr2)'은 expr1과 expr2가 같으면 NULL을, 같지 않으면 expr1을 반환한다.     |
| Coalesce | - Null이 아닌 최초의 인자 값을 반환한다.<br>Coalesce(exp1,exp2,exp3)은 exp1이 null이 아니면 exp1값을, 그렇지 않으면 그 뒤의 값의 null 여부를 판단하여 값을 반환한다. |

### 04. Group by 연산
: 테이블에서 소규모 행을 그룹화하여 합계, 평균, 최댓값, 최솟값 등을 계산할 수 있다. 
1. having 문 사용
```sql
select deptno, sum(sal) from EMP group by deptno having sum(sal) > 1000;
-- group by 결과에서 급여합계가 1000이상만 조회한다.
```

2. 집계함수 종류

| 집계 함수      | 설명          |
| ---------- | ----------- |
| Stddev()   | 표준편차를 계산한다. |
| variance() | 분산을 계산한다.   |
3. count 함수
```
count(*) 함수는 null 값을 포함한 모든 행수를 계산한다.
```

### 06. 명시적 형변환과 암시적 형변환
1. 명시적 형변환 
   : 형변환 함수를 사용해서 데이터 타입을 일치시키는 것.
   : 개발자가 sql을 사용할 때 형변환 함수를 사용해야 한다.

| 형변환 함수                      | 설명                              |
| --------------------------- | ------------------------------- |
| to_number(문자열)              | 문자열을 숫자로 변환한다.                  |
| to_char(숫자 혹은 날짜, [format]) | 숫자 혹은 날짜를 지정된 format의 문자로 변환한다. |
| to_date(문자열, format)        | 문자열을 지정된 format의 날짜형으로 변환한다.    |
2. 암시적 형변환
   : 개발자가 형변환을 하지 않은 경우 데이터베이스 관리 시스템이 자동으로 형변환하는 것을 의미한다. 

### 07. 내장형 함수 
1. 내장형 함수
   : 형변환 함수, 문자열 및 숫자형 함수, 날짜형 함수가 있다. 
2. dual 테이블
   : oracle데이터베이스에 의해서 자동으로 생성되는 테이블 
3. 내장형 함수의 종류 

| 함수                 | 설명                                                    |
| ------------------ | ----------------------------------------------------- |
| ascii              | 문자에 대한 ascii 코드 값을 알려준다                               |
| substar(문자열, m ,n) | 지정된 위치의 문자열을 자르는 함수<br>- 문자열에서 m번째 위치부터 n개를 자른다.      |
| len , length       | 문자열의 길이 계산                                            |
| ltrim              | 문자열의 왼쪽 공백을 제거할 수 있다.                                 |
| concat(문자열1, 문자열2) | 문자열 1과 문자열2를 결합한다.                                    |
| trim(문자열, 지정된 문자)  | -왼쪽 및 오른쪽에서 지정된 문자를 삭제한다.<br>- 지정된 문자를 생략하면 공백을 삭제한다. |

| 날짜형 함수                     | 설명                   |
| -------------------------- | -------------------- |
| sysdate                    | 오늘의 날짜를 날짜 타입으로 알려준다 |
| extract(year from sysdate) | 날짜에서 년, 월, 일을 조회한다.  |

| 숫자형 함수           | 설명                                   |
| ---------------- | ------------------------------------ |
| abs(숫자)          | 절댓값을 돌려준다.                           |
| sign(숫자)         | 양수, 음수, 0을 구별한다.                     |
| mod(숫자1, 숫자2)    | - 숫자1을 숫자2로 나누어 나머지를 계산한다.           |
| ceil/ceiling(숫자) | 숫자보다 크거나 같은 최소의 정수를 돌려준다.            |
| floor(숫자)        | 숫자보다 작거나 같은 최대의 정수를 돌려준다.            |
| round(숫자, m )    | - 소수점 m 자리에서 반올림한다.<br>- m의 기본값은 0이다 |
| trunc(숫자, m)     | - 소수점 m 자리에서 절삭한다.<br>- m의 기본값은 0이다. |
### 08. decode와 case문
1. decode
   : decode문으로 if문을 구현할 수 있다. 
   : 특정 조건이 참이면 a, 거짓이면 B로 응답한다.
```sql
decode(EMPNO, 1000, True, False)
-- 비교문으로 EMPNO가 1000이면 True를 응답하고 같지 않으면 False를 응답한다.
```
2. case문
   : 해당 조건이 참이면 Then이 실행되고, 거짓이면 else 구가 실행된다.
```sql 
case[expression]
	when condition_1 then result_1
	when condition_2 then result_2

	else result
end
```

### 09. with 문 
: with 문은 서브쿼리를 사용해서 임시 테이블이나 뷰처럼 사용할 수 있는 구문이다. 
```sql
-- emp 테이블에서 with구문을 사용해서 부서번호가 30인 것의 임시 테이블을 만들고 조회하라.

with W_EMP as 
	(select * from EMP where Deptno = 30) --만들고
	select * from w_emp -- 조회

```

# 02. SQL 활용
### 01. 서브 쿼리
1. 메인쿼리와 서브쿼리 
: 서브 쿼리는 select 문 내에 다시 select 문을 사용하는 sql문이다.
: 인라인 뷰 : from 구에 select문을 사용하는 것
: 스칼라 서브쿼리 : select문에 서브쿼리를 사용하는 것.
```sql
select *
	from EMP
	where deptno = 
		(select deptno from dept
			where deptno = 10);
-- where 문에 있는 select 구가 서브쿼리이고 괄호 내에 select 문을 사용한다.
-- 서브쿼리 밖에 있는 select문은 메인쿼리이다.
```

```sql
select *
	from (select rownum num, ename
			from emp) a
	where num < 5;
-- from 구에 있는 select문을 인라인 뷰라고 한다.
-- from 구에 select문을 사용하여 가상의 테이블을 만드는 효과를 얻을 수 있다.
-- 이렇게 from구에 select문을 사용한 것이 인라인 뷰이다.
```

02. 단일 행 서브쿼리와 다중 행 서브쿼리
- 서브쿼리의 종류 - 단일 행 서브쿼리, 멀티 행 서브쿼리
- 단일 행 서브쿼리 
  : 반환하는 행 수가 한 개인 것
  : 비교 연산자(=,<,>,<=등)를 사용한다
- 멀티 행 서브쿼리 
  : 반환하는 행 수가 여러 개인 것
  : in, any, all, exists를 사용한다. 

03. 다중 행 서브쿼리 

| 다중 행 연산          | 설명                                                                                                        |
| ---------------- | --------------------------------------------------------------------------------------------------------- |
| in(subquery)     | 메인 쿼리의 비교 조건이 서브쿼리의 결과 중 하나만 동일하면 참이 된다.                                                                  |
| all(subquery)    | - 메인 쿼리와 서브쿼리 결과가 모두 동일하면 참이 된다.<br>- < all : 최솟값을 반환한다.<br>- > all : 최댓값을 반환한다.                          |
| any(subquery)    | - 메인 쿼리의 비교조건이 서브쿼리의 결과 중 하나 이상 동일하면 참이 된다.<br>- < any : 하나라도 크게 되면 참이 된다.<br>- > any : 하나라도 작게 되면 참이 된다. |
| exists(subquery) | - 메인 쿼리와 서브쿼리의 결과가 하나라도 존재하면 참이 된다.                                                                       |

in ex) 
```sql 
select ename, dname, sal
	from emp, dept
where emp.depnto = dept.deptno
	and emp.empno
	in (select empno from emp
		where sal > 2000);
-- 급여가 2000보다 큰 사원 번호를 조회한 후에 emp의 empno를 조회한다.
```

all ex) 
```sql
select *
	from emp
	where deptno <= all (20,30)
-- deptno가 20, 30보다 작거나 같은 것을 조회한다.
```

exists ex) 
```sql 
select ename, dname, sal
	from emp, dept
where emp.deptno = dept.deptno
	and exists (select 1 from emp
		where sal > 2000) ; 
-- 급여가 2000보다 큰 사원이 있으면 true가 조회된다. 
```

04. 스칼라 서브쿼리
```sql
select ename as "이름",
		sal as '급여', 
		(select avg(sal)
			from emp
			) as "평균급여"
	from emp
where empno = 1000;
-- ()괄호 안에 스칼라 서브쿼리는 반드시 한 행과 한 칼럼만 반환하는 서브 쿼리이다. 
-- 만약, 여러 행이 반환되면 오류가 발생한다. 
```

05. 연관 서브쿼리 
    : 서브쿼리 내에서 메인 쿼리 내의 칼럼을 사용하는 것을 의미한다.
```sql 
from emp a
where a.deptno = 
	(select deptno from dept b
	where b.deptno = a.deptno)
-- a.deptno에서 메인 쿼리에서 데이터를 받아서 서브쿼리를 실행한다.
```

### 02. 조인
1. equi(등가) 조인 
   : 두 개의 테이블 간에 일치하는 것을 조인
```sql
select * from emp, dept
where emp.deptno = dept.deptno
-- =로 두 개의 테이블을 연결한다.
```

```sql 
select * from emp, dept
where emp.deptno = dept.deptno
	and emp.ename like '%임'
	order by ename;
-- 조인문에 추가 조건 및 정렬을 할 수 있다.
```

2. inner 조인
: on문을 사용해서 테이블을 연결한다.
```sql
select * from emp inner join dept -- inner join구로 테이블을 정의한다.
on emp.deptno = dept.deptno
-- on구를 사용해서 조인 조건을 넣는다.
```

3. intersect 연산 
   : 두 개의 테이블에서 교집합을 조회한다.
```sql 
select deptno from emp
intersect 
select deptno from dept;
```

4. outer join 
   : 두 테이블 간에 교집합을 조회하고 한쪽 테이블에만 있는 데이터도 포함시켜서 조회한다.
   : ex) dept테이블과 emp 테이블은 outer join하면 deptno가 같은 것을 조회하고 dept테이블에만 있는 deptno도 포함시킨다.
   : 왼쪽 테이블에만 있는 행도 포함하면 left outer join이라하고
   : 오른쪽 테이블에만 있는 행만 포함하면 right outer join이라한다.
   : 둘 다 있으면 full outer join 
   : oracle에서는 outer join을 할 때 "(+)"기호를 사용해서 할 수 있다.
```sql
select * from dept, emp
	where emp.deptno (+)= dept.deptno;
```

5. cross join 
   : 조인 조건구 없이 2개의 테이블을 하나로 조인한다. 
   : 조인구가 없기 때문에 카다시안 곱이 발생한다.
   (행이 14개 있는 테이블과 행이 4개 있는 테이블을 조인하면 56개의 행이 조회된다.)
```sql
select * from emp cross join dept;
```

6. union을 사용한 합집합 구현 
	- 
   : union 연산은 두 개의 테이블을 하나로 만드는 연산이다.
   : 두 개의 테이블의 칼럼 수, 칼럼 데이터 형식 모두가 일치해야한다. 
   : 두 개의 테이블을 하나로 합치면서 중복된 데이터를 제거한다.
   : 정렬(sort)과정을 발생시킨다.
```sql 
select deptno from emp
union
select deptno from emp
```

- **union all**
  : 두 개의 테이블을 하나로 합치는 것이다. 
  : union처럼 중복을 제거하거나 정렬을 유발하지 않는다.
```sql
select deptno from emp
union all
select deptno from emp;
```

7. **차집합을 만드는 minus**
: select문에는 있고 뒤에 쓰는 select 문에는 없는 집합을 조회하는 것이다.
```sql
select deptno from dept
minus
select deptno from emp
-- dept에는 10,20,30 이 있고
-- emp에는 10, 20이 있는 경우 
-- 출력은 30이 된다.
```

### 03. 그룹 함수
1. **rollup**
   : group by의 칼럼에 대해서 subtotal을 만들어준다
```sql 
select decode(deptno, null, '전체합계', deptno), 
		sum(sal)
	from emp
group by rollup(deptno)
-- rollup을 사용하면 부서별 합계 및 전체합계가 계산된다. 
```

2. grouping 함수
   : rollup, cube, grouping sets에서 생성되는 합계값을 구분하기 위해서 만들어진 함수. 
   : 소계, 합계 등이 계산되면 **grouping 함수는 1을 반환하고 그렇지 않으면 0을 반환해서 합계값을 식별할 수 있다.** 
```sql
select deptno, grouping(deptno),
	job, grouping()
```

3. **grouping sets함수** 
   : group by에 나오는 칼럼의 순서와 관계없이 다양한 소계를 만들 수 있다.
```sql
select deptno, job, sum(sal)
from emp
group by grouping sets(deptno, job);
-- deptno job을 각각이 그룹으로 합계를 계산한다.
```

4. **cube 함수**
   : cube 함수에서 제시한 칼럼에 대해서 **결합 가능한 모든 집계를 계산**한다. 
   : 조합할 수 있는 경우의 수가 모두 조합되는 것 
```sql
select deptno, job, sum(sal)
from emp
group by cube(deptno, job)
-- 모든 합계를 모두 계산하는 다차원 분석을 한다.
```

### 04. 윈도우 함수 
1. 윈도우 함수
   : 행과 행 간의 관계를 정의하기 위해서 제공하는 함수 
   : 윈도우 함수를 사용해서 순위, 합계, 평균, 행 위치 등을 조작할 수 있다.
   : 윈도우 함수 구조
```sql
select window_function(arguments)
	over(partition by 칼럼
		order by windowing절)
from 테이블명
```

- 윈도우 함수 구조

| 구조               | 설명                                                                |
| ---------------- | ----------------------------------------------------------------- |
| **aruments(인수)** | 윈도우 함수에 따라서 0~N개의 인수를 설정한다.                                       |
| **partition by** | 전체 집합을 기준에 의해 **소그룹**으로 나눈다.                                      |
| order by         | 어떤 항목에 대해서 정렬한다.                                                  |
| **windowing**    | - 행 기준의 범위를 정한다.<br>- rows는 물리적 결과의 행의 수이고 range는 논리적 값에 의한 범위이다. |

- windowing 

| 구조                  | 설명                                 |
| ------------------- | ---------------------------------- |
| rows                | 부분집합인 윈도우 크기를 물리적 단위로 행의 집합을 지정한다. |
| range               | 논리적인 주소에 의해 행 집합을 지정한다.            |
| between~and         | 윈도우의 시작과 끝의 위치를 지정한다               |
| unbounded preceding | 윈도우의 시작 위치가 첫 번째 행 임을 의미한다.        |
| unbounded following | 윈도우 마지막 위치가 마지막 행임을 의미한다.          |
| current row         | 윈도우 시작 위치가 현재 행임을 의미한다.            |

- windowing 예시 
```sql 
select empno, ename, sal,
	sum(sal) over(order by sal -- sal을 기준으로 정렬
			rows between unbounded preceding
			-- unbounded preceding 첫번째 행을 의미
			and unbounded following) total
			-- unbounded following 마지막 행을 의미
	from EMP;
-- 그럼 출력 결과가 
-- empno | ename | sal | total 이렇게 나오고 
-- total에 sal의 rows가 처음부터 끝까지 sum(sal)된 값으로 나온다 
```

2. 순위 함수

| 순위 함수      | 설명                          |
| ---------- | --------------------------- |
| rank       | - 특정항목 및 파티션에 대해서 순위를 계산한다. |
| dense_rank | - 동일한 순위를 하나의 건수로 계산한다.     |
| row_number | - 동일한 순위에 대해서 고유의 순위를 부여한다. |
```sql 
select ename, sal,
	rank() over (order by sal desc) all rank,
	-- sal을 내림차순 정리한 것의 순위를 all rank라는 이름으로 
	rank() over (partition by job order by sal desc) job rank
	-- sal을 내림차순 정리하고 job으로 파티션을 만들고 순위를 job rank라는 이름으로
```

+) 파티션이 뭘까? 
: partition by절은 데이터를 특정 기준으로 나누어 각 파티션 내에서 별도롤 윈도우 함수를 적용할 수 있도록 한다. 
: 파티션이란, 일종의 그룹이라고 생각할 수 있으며, 
: 각 파티션마다 독립적으로 집계나 순위를 계산할 수 있다. 
![](Pasted%20image%2020240806204651.png)

4. 행 순서 관련 함수

| 행 순서        | 설명                                                           |
| ----------- | ------------------------------------------------------------ |
| first_value | - 파티션에서 가장 처음 나오는 값을 구한다.<br>- min 함수를 사용해서 같은 결과를 구할 수 있다.  |
| last_value  | - 파티션에서 가장 나중에 나오는 값을 구한다.<br>- max 함수를 사용해서 같은 결과를 구할 수 있다. |
| lag         | 이전 행을 가지고 온다.                                                |
| lead        | - 윈도우에서 특정 위치의 행을 가지고 온다.<br>- 기본값은 1이다                      |

```sql
select deptno, ename, sal,
	first_value(ename) over ( -- 파티션에서 가장 처음 나온 값을 구한다.
	partition by deptno -- deptno를 독립된 파티션으로 지정할거고
	order by sal desc  -- sal을 기준으로 내림차순 정렬할거고 
	rows unbounded preceding) -- 첫번째 행부터 현재까지의 모든 행을 윈도우 프레임으로 분할할 것이다. 
	as dept_a from emp; -- 그 행 이름을 dept_a라고 할거다 
	-- 이 모든 테이블은 emp에서! 
```



